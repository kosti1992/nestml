from pacman.executor.injection_decorator import inject_items
from pacman.model.decorators import overrides
from spynnaker.pyNN.models.abstract_models import AbstractContainsUnits
from spynnaker.pyNN.models.neural_properties import NeuronParameter
from .abstract_neuron_model import AbstractNeuronModel
from spynnaker.pyNN.utilities import utility_calls

from data_specification.enums import DataType

from enum import Enum


class _{{neuronName.upper()}}_TYPES(Enum):
    A = (1, DataType.S1615)
    B = (2, DataType.S1615)
    C = (3, DataType.S1615)
    D = (4, DataType.S1615)
    V_INIT = (5, DataType.S1615)
    U_INIT = (6, DataType.S1615)
    I_OFFSET = (7, DataType.S1615)
    THIS_H = (8, DataType.S1615)

    def __new__(cls, value, data_type):
        obj = object.__new__(cls)
        obj._value_ = value
        obj._data_type = data_type
        return obj

    @property
    def data_type(self):
        return self._data_type


class _{{neuronName.upper()}}_GLOBAL_TYPES(Enum):
    TIMESTEP = (1, DataType.S1615)

    def __new__(cls, value, data_type):
        obj = object.__new__(cls)
        obj._value_ = value
        obj._data_type = data_type
        return obj

    @property
    def data_type(self):
        return self._data_type


class NeuronModel{{neuronName}}(AbstractNeuronModel, AbstractContainsUnits):

    def __init__(self, n_neurons, {%for parameter in neuron.getParameterSymbols()%}{{names.convertToCPPName(parameter.getSymbolName())}}{% if parameter != (neuron.getParameterSymbols()|last) %}, {% endif %}{% endfor %}):
        AbstractNeuronModel.__init__(self)
        AbstractContainsUnits.__init__(self)

        self._units = {
         {% for parameter in neuron.getParameterSymbols() -%}
            '{{names.convertToCPPName(parameter.getSymbolName())}}': "{{parameter.getTypeSymbol().printSymbol()}}"{%- if parameter != (neuron.getParameterSymbols()|last) %},{% endif %}
         {% endfor -%}
        }

        self._n_neurons = n_neurons
        {% for parameter in neuron.getParameterSymbols() -%}
            self._{{names.convertToCPPName(parameter.getSymbolName())}} = utility_calls.convert_param_to_numpy({{names.convertToCPPName(parameter.getSymbolName())}}, n_neurons)
        {% endfor -%}


    {% for parameter in neuron.getParameterSymbols() %}
    @property
    def {{names.convertToCPPName(parameter.getSymbolName())}}(self):
        return self._{{names.convertToCPPName(parameter.getSymbolName())}}
    @{{names.convertToCPPName(parameter.getSymbolName())}}.setter
    def {{names.convertToCPPName(parameter.getSymbolName())}}(self, {{names.convertToCPPName(parameter.getSymbolName())}}):
        self._{{names.convertToCPPName(parameter.getSymbolName())}} = utility_calls.convert_param_to_numpy({{names.convertToCPPName(parameter.getSymbolName())}}, self._n_neurons)
    {% endfor %}

    # TODO...

    def initialize_v(self, v_init):
        self._v_init = utility_calls.convert_param_to_numpy(
            v_init, self._n_neurons)

    def initialize_u(self, u_init):
        self._u_init = utility_calls.convert_param_to_numpy(
            u_init, self._n_neurons)

    @overrides(AbstractNeuronModel.get_n_neural_parameters)
    def get_n_neural_parameters(self):
        return 8

    @inject_items({"machine_time_step": "MachineTimeStep"})
    @overrides(AbstractNeuronModel.get_neural_parameters,
               additional_arguments={'machine_time_step'})
    def get_neural_parameters(self, machine_time_step):
        return [

            # REAL A
            NeuronParameter(self._a, _IZH_TYPES.A.data_type),

            # REAL B
            NeuronParameter(self._b, _IZH_TYPES.B.data_type),

            # REAL C
            NeuronParameter(self._c, _IZH_TYPES.C.data_type),

            # REAL D
            NeuronParameter(self._d, _IZH_TYPES.D.data_type),

            # REAL V
            NeuronParameter(self._v_init, _IZH_TYPES.V_INIT.data_type),

            # REAL U
            NeuronParameter(self._u_init, _IZH_TYPES.U_INIT.data_type),

            # offset current [nA]
            # REAL I_offset;
            NeuronParameter(self._i_offset, _IZH_TYPES.I_OFFSET.data_type),

            # current timestep - simple correction for threshold
            # REAL this_h;
            NeuronParameter(
                machine_time_step / 1000.0, _IZH_TYPES.THIS_H.data_type)
        ]

    @overrides(AbstractNeuronModel.get_neural_parameter_types)
    def get_neural_parameter_types(self):
        return [item.data_type for item in _IZH_TYPES]

    @overrides(AbstractNeuronModel.get_n_global_parameters)
    def get_n_global_parameters(self):
        return 1

    @inject_items({"machine_time_step": "MachineTimeStep"})
    @overrides(AbstractNeuronModel.get_global_parameters,
               additional_arguments={'machine_time_step'})
    def get_global_parameters(self, machine_time_step):
        return [
            NeuronParameter(
                machine_time_step / 1000.0,
                _IZH_GLOBAL_TYPES.TIMESTEP.data_type)
        ]

    @overrides(AbstractNeuronModel.get_global_parameter_types)
    def get_global_parameter_types(self):
        return [item.data_type for item in _IZH_GLOBAL_TYPES]

    @overrides(AbstractNeuronModel.set_neural_parameters)
    def set_neural_parameters(self, neural_parameters, vertex_slice):
        self._v_init[vertex_slice.as_slice] = neural_parameters[4]
        self._u_init[vertex_slice.as_slice] = neural_parameters[5]

    def get_n_cpu_cycles_per_neuron(self):

        # A bit of a guess
        return 150

    @overrides(AbstractContainsUnits.get_units)
    def get_units(self, variable):
        return self._units[variable]